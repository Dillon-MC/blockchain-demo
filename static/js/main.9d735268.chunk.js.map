{"version":3,"sources":["components/AddBlockForm/createBlock.ts","components/Block/Block.tsx","components/Chain/Chain.tsx","components/Peer/Peer.tsx","components/PeerList/PeerList.tsx","components/AddPeerBtn/AddPeerBtn.tsx","components/AddBlockForm/AddBlockForm.tsx","components/Peer/constants.ts","components/Peer/peerHandler.ts","containers/App.tsx","reportWebVitals.js","index.js"],"names":["crypto","require","createBlock","a","index","data","prevBlock","newBlock","nonce","timestamp","Date","toUTCString","prevHash","hash","createHashSync","then","newHash","Promise","resolve","block","slice","createHash","update","digest","Block","blockData","selectedPeer","appContext","useAppContext","changeHash","setRefreshes","refreshes","isHashValid","updatePrecedingBlockHashes","i","chains","length","className","name","type","value","onChange","e","updateBlock","target","style","color","borderColor","backgroundColor","onClick","Chain","props","children","config","dictionaries","names","Peer","peerIndex","selectPeer","setCurrentChain","useState","peerName","setPeerName","useEffect","uniqueNamesGenerator","isSelectedPeer","setIsSelectedPeer","shouldUpdate","peers","getConnectedPeers","includes","disconnectPeer","peer","stopPropagation","connectToPeer","PeerList","AddPeerBtn","addPeer","isDisabled","setIsDisabled","disabled","setTimeout","addChain","AddBlockForm","blockdata","setBlockdata","placeholder","id","addBlockToChain","sendBlockToPeers","chain","REQUEST_CHAIN","BLOCK","peerHandler","_connectedPeers","processRecievedBlock","latestBlock","processRecievedChain","forEach","p","processMessage","event","msg","newChain","sort","block1","block2","isChainValid","replaceChain","console","log","createHashASync","requestLatestBlock","push","splice","indexOf","stateContext","v","setPeerChain","AppContext","createContext","useContext","App","createGenesisBlock","createBlockCopy","setSelectedPeer","setChains","currentChain","genesisBlock","Provider","blockCopy","chainIndex","map","reportWebVitals","onPerfEntry","Function","getCLS","getFID","getFCP","getLCP","getTTFB","ReactDOM","render","StrictMode","document","getElementById"],"mappings":"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","file":"static/js/main.9d735268.chunk.js","sourcesContent":["const crypto = require('crypto');\r\n\r\ninterface IBlockProps {\r\n    index: number,\r\n    nonce: number,\r\n    data: string,\r\n    timestamp: string,\r\n    prevHash: string,\r\n    hash: string\r\n}\r\n\r\ninterface ICreateBlockProps {\r\n    index: number,\r\n    data: string,\r\n    prevBlock: IBlockProps | null\r\n}\r\n\r\nexport const createBlock = async({ index, data, prevBlock }: ICreateBlockProps): Promise<IBlockProps> => {\r\n    const newBlock: IBlockProps = {\r\n        index: index,\r\n        nonce: 0,\r\n        data: data,\r\n        timestamp: prevBlock ? new Date().toUTCString() : 'Sat, 24 Apr 2021 14:32:41 GMT',\r\n        prevHash: prevBlock ? prevBlock.hash : '0',\r\n        hash: ''\r\n    }\r\n\r\n    createHashSync(newBlock).then(newHash => newBlock.hash = newHash);\r\n\r\n    return Promise.resolve(newBlock);\r\n}\r\n\r\nexport const createHashSync = async (block: IBlockProps): Promise<string> => {\r\n    let hash = block.hash;\r\n    if(hash.slice(0, 3) === \"000\") {\r\n        return Promise.resolve(hash);\r\n    }\r\n    \r\n    while(hash.slice(0, 3) !== \"000\") {\r\n        block.nonce++;\r\n        hash = crypto.createHash('SHA256').update(\r\n            block.index+\r\n            block.timestamp+\r\n            `${block.data}`+\r\n            block.prevHash+\r\n            block.nonce\r\n        ).digest('hex');\r\n    }\r\n    return Promise.resolve(hash);\r\n}\r\n\r\nexport const createHashASync = (block: IBlockProps): string => {\r\n    let hash = block.hash;\r\n    if(hash.slice(0, 3) === \"000\") {\r\n        return hash;\r\n    }\r\n    \r\n    while(hash.slice(0, 3) !== \"000\") {\r\n        block.nonce++;\r\n        hash = crypto.createHash('SHA256').update(\r\n            block.index+\r\n            block.timestamp+\r\n            `${block.data}`+\r\n            block.prevHash+\r\n            block.nonce\r\n        ).digest('hex');\r\n    }\r\n    return hash;\r\n}","import './Block.css';\r\nimport { useAppContext } from '../../containers/App';\r\nimport crypto from 'crypto';\r\nimport { createHashSync } from '../AddBlockForm/createBlock';\r\n\r\nexport interface IBlockProps {\r\n    index: number,\r\n    nonce: number,\r\n    data: string,\r\n    timestamp: string,\r\n    prevHash: string,\r\n    hash: string\r\n}\r\n\r\nconst Block = ({blockData, selectedPeer}: {blockData: IBlockProps, selectedPeer: number}): JSX.Element => {\r\n    const appContext = useAppContext();\r\n\r\n    // changes the blocks hash\r\n    const changeHash = (block: IBlockProps): string => {\r\n        appContext.setRefreshes(appContext.refreshes++);\r\n        return crypto.createHash('SHA256').update(\r\n            block.index+\r\n            block.timestamp+\r\n            `${block.data}`+\r\n            block.prevHash+\r\n            block.nonce\r\n        ).digest('hex');\r\n    }\r\n\r\n    // update the block when it is changed\r\n    const updateBlock = (data: string): void => {\r\n        let block = appContext.chains[selectedPeer][blockData.index];\r\n        block.data = data;\r\n        // update the blocks hash when the data is changed\r\n        block.hash = changeHash(block);\r\n        // refresh block when changes are made\r\n        appContext.setRefreshes(appContext.refreshes++);\r\n        updatePrecedingBlockHashes();\r\n    }\r\n\r\n    const isHashValid = (): boolean => {\r\n        if(blockData.hash.slice(0,3) !== \"000\") {\r\n            return false;\r\n        }\r\n        return true;\r\n    }\r\n\r\n    const isPrevHashValid = (): boolean => {\r\n        if(blockData.prevHash.slice(0,3) !== \"000\" && blockData.index > 0) {\r\n            return false;\r\n        }\r\n        return true;\r\n    }\r\n\r\n    //re-mine the block to find a valid hash\r\n    const mineBlock = (): void => {\r\n        createHashSync(blockData)\r\n        .then(newHash => {\r\n            appContext.chains[selectedPeer][blockData.index].hash = newHash;\r\n            appContext.chains[selectedPeer][blockData.index].timestamp = new Date().toUTCString();\r\n            appContext.setRefreshes(appContext.refreshes++);\r\n            // update the hashes of all other blocks in the chain that come after this one\r\n            updatePrecedingBlockHashes();\r\n        });\r\n        appContext.setRefreshes(appContext.refreshes++);\r\n    }\r\n\r\n    const updatePrecedingBlockHashes = (): void => {\r\n        // update the hashes of all other blocks in the chain that come after this one\r\n        for(let i = blockData.index+1; i < appContext.chains[selectedPeer].length; i++) {\r\n            let block = appContext.chains[selectedPeer][i];\r\n            if(block.index > 0) {\r\n                block.prevHash = appContext.chains[selectedPeer][i-1].hash;\r\n            }\r\n            block.hash = changeHash(block);\r\n            appContext.setRefreshes(appContext.refreshes++);\r\n        }\r\n    }\r\n\r\n    return (\r\n        <div className=\"block\">\r\n            <span className=\"blockheader\">\r\n                <h4>{`INDEX: #${blockData.index}`}</h4>\r\n                <h5>{blockData.nonce}</h5>\r\n            </span>\r\n            <input className=\"blockdatainput\" name={\"blockdatainput\"} type=\"text\" value={blockData.data} onChange={(e) => updateBlock(e.target.value)}/>\r\n            <div className=\"hashcontainer\">\r\n                <h6>PREVIOUS HASH</h6>\r\n                <div className=\"prevhash hash\" style={\r\n                    // if the previous hash is invalid change the colors to red\r\n                    isPrevHashValid() ? {color:'rgb(62, 238, 120)', borderColor:'rgb(62, 238, 120)', backgroundColor:'rgb(181, 241, 201)'}\r\n                    :\r\n                    {color:'red', borderColor:'rgb(238, 62, 62)', backgroundColor:'rgb(241, 181, 181)'}\r\n                }>\r\n                    {blockData.prevHash}\r\n                </div>\r\n                <h6>HASH</h6>\r\n                <div className=\"hash\" style={\r\n                    // if the hash is invalid change the colors to red\r\n                    isHashValid() ? {color:'rgb(62, 238, 120)', borderColor:'rgb(62, 238, 120)', backgroundColor:'rgb(181, 241, 201)'}\r\n                    :\r\n                    {color:'red', borderColor:'rgb(238, 62, 62)', backgroundColor:'rgb(241, 181, 181)'}\r\n                }>\r\n                    {blockData.hash}\r\n                </div>\r\n            </div>\r\n\r\n            {/* display button to mine block if the hash is invalid */}\r\n            {!isHashValid() &&\r\n            <span className=\"material-icons mineblockbtn\" onClick={mineBlock}>\r\n                <div className=\"tooltip\">MINE</div>\r\n                build_circle\r\n            </span>}\r\n            \r\n            <footer>{blockData.timestamp}</footer>\r\n        </div>\r\n    );\r\n}\r\n\r\nexport default Block;","import React from 'react';\r\nimport './Chain.css';\r\n\r\ninterface IChainProps {\r\n    children: React.ReactNode\r\n}\r\n\r\nconst Chain = (props: IChainProps): JSX.Element => {\r\n    return (\r\n        <div className=\"chain\">\r\n            {props.children}\r\n        </div>\r\n    );\r\n}\r\n\r\nexport default Chain;","import { useEffect, useState } from 'react';\r\nimport './Peer.css';\r\nimport { useAppContext } from '../../containers/App';\r\nimport { uniqueNamesGenerator, Config, names } from 'unique-names-generator';\r\n\r\nconst config: Config = {\r\n    dictionaries: [names]\r\n}\r\n\r\nexport interface IPeerProps {\r\n    peerIndex: number,\r\n    selectedPeer: number,\r\n    selectPeer: Function,\r\n    setCurrentChain: Function\r\n}\r\n\r\nconst Peer = ({selectedPeer, peerIndex, selectPeer, setCurrentChain }: IPeerProps): JSX.Element => {\r\n    const [peerName, setPeerName] = useState<string>('');\r\n    useEffect(() => {\r\n        setPeerName(uniqueNamesGenerator(config));\r\n    },[])\r\n\r\n    const [isSelectedPeer, setIsSelectedPeer] = useState<boolean>(false);\r\n    //causes the component to re-render\r\n    const [shouldUpdate, update] = useState<number>(0);\r\n    const appContext = useAppContext();\r\n    const index = peerIndex;\r\n\r\n    useEffect(() => {\r\n        setIsSelectedPeer(selectedPeer === index ? true : false);\r\n    },[selectedPeer,shouldUpdate]);\r\n\r\n    const setAsSelectedPeer = (): void => {\r\n        selectPeer(index);\r\n        setCurrentChain(appContext.chains[index]);\r\n    }\r\n\r\n    return (\r\n        <div className=\"peer\" onClick={setAsSelectedPeer}>\r\n            {!isSelectedPeer ? appContext.peers[index].getConnectedPeers().includes(selectedPeer) ? \r\n                <span className=\"material-icons toggleconnectIcon\" style={{color:'red'}} onClick={(e) => {\r\n                    appContext.peers[index].disconnectPeer({ peer: selectedPeer, appContext });\r\n                    update(shouldUpdate === 0 ? 1 : 0);\r\n                    e.stopPropagation();\r\n                }}>\r\n                    remove_circle\r\n                </span>\r\n            :\r\n                <span onClick={(e) => {\r\n                        appContext.peers[index].connectToPeer({ appContext, peerIndex: selectedPeer });\r\n                        update(shouldUpdate === 0 ? 1 : 0);\r\n                        e.stopPropagation();\r\n                    }} className=\"material-icons toggleconnectIcon\">\r\n                    add_circle\r\n                </span>\r\n            : null}\r\n\r\n            <span className=\"material-icons peerIcon\" style={     \r\n                isSelectedPeer ? {color: 'darkgray'} \r\n                : \r\n                appContext.peers[index].getConnectedPeers().includes(selectedPeer) ? {color: 'rgb(20, 230,  120)'}\r\n                :\r\n                {color: 'rgb(71, 135, 255)'}\r\n            }>\r\n                account_circle\r\n            </span>\r\n            <div>{peerName}</div>\r\n        </div>\r\n    );\r\n}\r\n\r\nexport default Peer;","import React from 'react';\r\nimport './PeerList.css';\r\n\r\ninterface IPeerListProps {\r\n    children: React.ReactNode\r\n}\r\n\r\nconst PeerList = (props: IPeerListProps): JSX.Element => {\r\n    return (\r\n        <div className=\"peerlist\">\r\n            {props.children}\r\n        </div>\r\n    );\r\n}\r\n\r\nexport default PeerList;","import { useState } from 'react';\r\nimport './AddPeerBtn.css';\r\nimport { useAppContext } from '../../containers/App';\r\n\r\nconst AddPeerBtn = ({addPeer}: {addPeer: Function}): JSX.Element => {\r\n    const appContext = useAppContext();\r\n    const [isDisabled, setIsDisabled] = useState<boolean>(false);\r\n\r\n    //adds a cooldown to stop the user from spamming the button\r\n    const disableButton = () => {\r\n        setIsDisabled(true);\r\n        setTimeout(() => {\r\n            setIsDisabled(false);\r\n        }, 700);\r\n    }\r\n\r\n    return (\r\n        <button className=\"addpeerbtn\" disabled={isDisabled} onClick={(): void => {\r\n            disableButton();\r\n            appContext.addChain();\r\n            addPeer();\r\n        }}>\r\n            <div className=\"tooltip\">ADD PEER</div>\r\n            <span className=\"material-icons\">\r\n                add\r\n            </span>\r\n        </button>\r\n    );\r\n}\r\n\r\nexport default AddPeerBtn;","import './AddBlockForm.css';\r\nimport { useAppContext } from '../../containers/App';\r\nimport { createBlock } from './createBlock';\r\nimport { useState } from 'react';\r\n\r\ninterface IAddBlockFormProps {\r\n    selectedPeer: number\r\n}\r\n\r\nconst AddBlockForm = ({selectedPeer}: IAddBlockFormProps): JSX.Element => {\r\n    const appContext = useAppContext();\r\n    const [blockdata, setBlockdata] = useState<string>('');\r\n    \r\n    const addBlock = (): void => {\r\n        createBlock({\r\n            index: appContext.chains[selectedPeer].length, \r\n            data: blockdata, \r\n            prevBlock: appContext.chains[selectedPeer][appContext.chains[selectedPeer].length-1]\r\n        }).then(newBlock => {\r\n            appContext.addBlockToChain(newBlock, selectedPeer);\r\n            appContext.peers[selectedPeer].sendBlockToPeers({ block: newBlock, appContext, chain: appContext.chains[selectedPeer] });\r\n            return;\r\n        });\r\n    }\r\n\r\n    return (\r\n        <div className=\"addblockform\">\r\n            <div className=\"container\">\r\n                <input className=\"blockdatainput\" type=\"text\" \r\n                    placeholder={`BLOCK #${appContext.chains[selectedPeer].length}`} onChange={(e) => {setBlockdata(e.target.value)}}/>\r\n\r\n                <button id=\"addblockbtn\" onClick={addBlock}>\r\n                        Add Block\r\n                </button>\r\n            </div>\r\n        </div>\r\n    );\r\n}\r\n\r\nexport default AddBlockForm;","export const REQUEST_CHAIN: string = \"REQUEST_CHAIN\";\r\nexport const BLOCK: string = \"BLOCK\";","import { IBlockProps } from '../Block/Block';\r\nimport { createHashASync } from '../AddBlockForm/createBlock';\r\nimport {\r\n    REQUEST_CHAIN,\r\n    BLOCK\r\n} from './constants';\r\n\r\ninterface IContextProps {\r\n    peers: Array<IPeerHandler>\r\n    chains: Array<Array<IBlockProps>>,\r\n    setPeerChain: Function,\r\n    addBlockToChain: Function,\r\n    addChain: Function,\r\n    replaceChain: Function\r\n}\r\n\r\nexport interface IPeerHandler {\r\n    processMessage: Function,\r\n    requestLatestBlock: Function,\r\n    connectToPeer: Function,\r\n    disconnectPeer: Function,\r\n    getConnectedPeers: Function,\r\n    sendBlockToPeers: Function\r\n}\r\n\r\nexport const peerHandler = (index: number): IPeerHandler => {\r\n    let _connectedPeers: Array<number> = [];\r\n\r\n    const processMessage = ({event, msg}: {event: string, msg: any}): void => {\r\n        switch(event) {\r\n            case BLOCK:\r\n                processRecievedBlock({...msg});\r\n                break;\r\n            case REQUEST_CHAIN:\r\n                processRecievedChain({...msg});\r\n                break;\r\n            default:\r\n                break;\r\n        }\r\n    }\r\n\r\n    const getConnectedPeers = (): Array<number> => {\r\n        return _connectedPeers;\r\n    }\r\n\r\n    const connectToPeer = ({appContext, peerIndex}: {appContext: IContextProps, peerIndex: number}) => {\r\n        if(!_connectedPeers.includes(peerIndex)) {\r\n            _connectedPeers.push(peerIndex);\r\n            // tell other peer to connect to this one as well to form a 2 way connection\r\n            appContext.peers[peerIndex].connectToPeer({ appContext, peerIndex: index });\r\n            //request the latest block from the peer we connected to\r\n            appContext.peers[peerIndex].requestLatestBlock({appContext, peerIndex: index});\r\n        }\r\n    }\r\n\r\n    const disconnectPeer = ({peer, appContext}: {peer: number, appContext: IContextProps}) => {\r\n        if(_connectedPeers.includes(peer)) {\r\n            _connectedPeers.splice(_connectedPeers.indexOf(peer), 1);\r\n            // tell the other peer to disconnect from this peer as well\r\n            appContext.peers[peer].disconnectPeer({peer: index, appContext});\r\n        }\r\n    }\r\n\r\n    const requestLatestBlock = ({appContext, peerIndex}: {appContext: IContextProps, peerIndex: number}): void => {\r\n        let chain = appContext.chains[index];\r\n        //sends the peers latest block to connected peer\r\n        appContext.peers[peerIndex].processMessage({event: BLOCK, msg: { block: chain[chain.length-1], chain, appContext }});\r\n    }\r\n\r\n    const processRecievedBlock = ({ block, chain, appContext}: {block: IBlockProps, chain: Array<IBlockProps>, appContext: IContextProps}): void => {\r\n        //grab this peers latest block\r\n        let latestBlock = appContext.chains[index][appContext.chains[index].length-1];\r\n        let newBlock = block;\r\n        if(newBlock.hash.slice(0,3) !== \"000\")\r\n            return;\r\n        if(newBlock.index > 0) {\r\n            if(newBlock.prevHash.slice(0,3) !== \"000\")\r\n                return;\r\n        }\r\n        if(newBlock.index <= latestBlock.index) {\r\n            // new block index is not greater than latest block, do nothing\r\n            return;\r\n        } else if(newBlock.prevHash === latestBlock.hash) {\r\n            // the new blocks hash is equal to the latest blocks hash, the peer is one block ahead\r\n            // append new block to the chain and tell all connected peers to do the same\r\n            appContext.addBlockToChain(newBlock, index);\r\n            sendBlockToPeers({ block, appContext, chain });\r\n            return;\r\n        } else {\r\n            // this peer is multiple blocks behind, request the entire chain and tell connected peers to do the same\r\n            processRecievedChain({ chain, appContext });\r\n            _connectedPeers.forEach(p => appContext.peers[p].processMessage({ event: REQUEST_CHAIN, msg: { chain, appContext }}));\r\n            return;\r\n        }\r\n    }\r\n\r\n    const processRecievedChain = ({chain, appContext}: {chain: Array<IBlockProps>, appContext: IContextProps}): void => {\r\n        let newChain = chain.sort((block1, block2) => (block1.index - block2.index));\r\n        if(newChain.length >= appContext.chains[index].length && isChainValid({ chain, appContext })) {\r\n            appContext.replaceChain(index, newChain);\r\n        }\r\n    }\r\n\r\n    const isChainValid = ({chain, appContext}: {chain: Array<IBlockProps>, appContext: IContextProps}): boolean => {\r\n        // is the new chains genesis block valid\r\n        let prevBlock = chain[0];\r\n        if(!isHashValid(appContext.chains[index][0].hash, prevBlock)) {\r\n            // new chain genesis block is invalid, return false\r\n            console.log('invalid chain')\r\n            return false;\r\n        }\r\n\r\n        for(const block of chain) {\r\n            if(block.prevHash !== prevBlock.hash && block.index !== 0) {\r\n                // if this is not the genesis block and it's prevhash is not equal to the prevblocks hash,\r\n                // then return false\r\n                return false;\r\n            } else if(block.hash.slice(0, 3) !== \"000\") {\r\n                // this blocks hash does not begin with \"000\" it is invalid, return false\r\n                return false;\r\n            } else {\r\n                // all checks have passed, set prevBlock to this block and continue\r\n                prevBlock = block;\r\n            }\r\n        }\r\n        // the chain is valid, return true\r\n        return true;\r\n    }\r\n\r\n    const isHashValid = (hash: string, prevBlock: IBlockProps): boolean => {\r\n        let prevBlockHash = createHashASync(prevBlock);\r\n        return prevBlockHash === hash;\r\n    }\r\n\r\n    const sendBlockToPeers = ({block, appContext, chain}: {block: IBlockProps, appContext: IContextProps, chain: Array<IBlockProps>}) => {\r\n        _connectedPeers.forEach(p => {\r\n            appContext.peers[p].processMessage({event: BLOCK, msg: { block, chain, appContext }});\r\n        });\r\n    }\r\n\r\n    return {\r\n        processMessage,\r\n        requestLatestBlock,\r\n        connectToPeer,\r\n        disconnectPeer,\r\n        sendBlockToPeers,\r\n        getConnectedPeers\r\n    }\r\n}","import './App.css';\nimport { createContext, useContext, useEffect } from 'react';\nimport Block, { IBlockProps } from '../components/Block/Block';\nimport Chain from '../components/Chain/Chain';\nimport Peer from '../components/Peer/Peer';\nimport PeerList from '../components/PeerList/PeerList';\nimport AddPeerBtn from '../components/AddPeerBtn/AddPeerBtn';\nimport AddBlockForm from '../components/AddBlockForm/AddBlockForm';\nimport { createBlock } from '../components/AddBlockForm/createBlock';\nimport { useState } from 'react';\nimport { peerHandler, IPeerHandler } from '../components/Peer/peerHandler';\n\ninterface IContextProps {\n  refreshes: number,\n  peers: Array<IPeerHandler>,\n  chains: Array<Array<IBlockProps>>,\n  setRefreshes: Function,\n  setPeerChain: Function,\n  addBlockToChain: Function,\n  addChain: Function,\n  replaceChain: Function\n}\n\nconst stateContext: IContextProps = {\n  refreshes: 0,\n  peers: [peerHandler(0)],\n  chains: [[]],\n  setRefreshes: (v: number): void => {},\n  setPeerChain: (peerIndex: number, chain: Array<IBlockProps>): void => {},\n  addBlockToChain: (peerIndex: number, block: IBlockProps): void => {},\n  addChain: (): void => {},\n  replaceChain: (chain: Array<IBlockProps>, newChain: Array<IBlockProps>): void => {}\n}\n\nconst AppContext = createContext(stateContext);\n\nexport const useAppContext = (): IContextProps => {\n  return useContext(AppContext);\n}\n\nfunction App() {\n  const [refreshes, setRefreshes] = useState<number>(useAppContext().refreshes);\n\n  const createGenesisBlock = async (): Promise<IBlockProps> => {\n    return createBlock({ index: 0, data: 'genesis block', prevBlock: null })\n    .then(block =>  block);\n  }\n\n  //when a peer adds a block to its chain, all connected peers will create a copy of that block to add to their own chain\n  const createBlockCopy = (block: IBlockProps): IBlockProps => {\n    return {\n      index: block.index,\n      nonce: block.nonce,\n      data: `${block.data}`,\n      timestamp: new Date().toUTCString(),\n      prevHash: `${block.prevHash}`,\n      hash: `${block.hash}`\n    }\n  }\n\n  const [peers, addPeer] = useState<Array<IPeerHandler>>([peerHandler(0)]);\n  const [selectedPeer, setSelectedPeer] = useState<number>(0);\n  const [chains, setChains] = useState<Array<Array<IBlockProps>>>([[]]);\n\n  const [currentChain, setCurrentChain] = useState<Array<IBlockProps>>(chains[0]);\n\n  useEffect(() => {\n    createGenesisBlock().then(genesisBlock => {\n      setChains([[genesisBlock]])\n      setCurrentChain([genesisBlock]);\n    });\n  },[])\n\n  const setPeerChain = (peerIndex: number, chain: Array<IBlockProps>): void => {\n    chains[peerIndex] = chain;\n  }\n\n  // adds the given block to the peers chain\n  const addBlockToChain = (block: IBlockProps, peer: number): void => {\n    const blockCopy = createBlockCopy(block);\n    chains[peer] = [...chains[peer], blockCopy];\n    peer === selectedPeer && setCurrentChain([...currentChain, blockCopy]);\n  }\n\n  const addChain = (): void => {\n    createGenesisBlock().then(genesisBlock => setChains([...chains, [genesisBlock]]));\n  }\n\n  const replaceChain = (chainIndex: number, newChain: Array<IBlockProps>): void => {\n    chains[chainIndex] = [];\n    newChain.forEach(block => {\n      chains[chainIndex].push(createBlockCopy(block));\n    });\n    setCurrentChain(newChain);\n  }\n\n  return (\n    <div className=\"App\">\n      <AppContext.Provider value={{ refreshes, setRefreshes, peers, chains, setPeerChain, addBlockToChain, addChain, replaceChain }}>\n        <PeerList>\n          {peers.map((peer, index) => {\n            return <Peer peerIndex={index} selectedPeer={selectedPeer} selectPeer={setSelectedPeer} setCurrentChain={setCurrentChain} key={`p${index}`} />\n          })}\n        </PeerList>\n        <AddBlockForm selectedPeer={selectedPeer}/>\n\n        <AddPeerBtn addPeer={()=>{ addPeer([...peers, peerHandler(peers.length)]) }}/>\n\n        <Chain>\n          {currentChain && currentChain.map(block => <Block blockData={block} selectedPeer={selectedPeer} key={block.index+selectedPeer}/>)}\n        </Chain>\n      </AppContext.Provider>\n    </div>\n  );\n}\n\nexport default App;\n","const reportWebVitals = onPerfEntry => {\n  if (onPerfEntry && onPerfEntry instanceof Function) {\n    import('web-vitals').then(({ getCLS, getFID, getFCP, getLCP, getTTFB }) => {\n      getCLS(onPerfEntry);\n      getFID(onPerfEntry);\n      getFCP(onPerfEntry);\n      getLCP(onPerfEntry);\n      getTTFB(onPerfEntry);\n    });\n  }\n};\n\nexport default reportWebVitals;\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './containers/App';\nimport reportWebVitals from './reportWebVitals';\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n\n// If you want to start measuring performance in your app, pass a function\n// to log results (for example: reportWebVitals(console.log))\n// or send to an analytics endpoint. Learn more: https://bit.ly/CRA-vitals\nreportWebVitals();\n"],"sourceRoot":""}